------------------ ***** -----------------------------
-- Migration de la grammaire de LACTION-- vers la nouvelle syntaxe
------------------ ***** -----------------------------
--OPTIONS
option k =2;
option auto =true;
option version =5.2.8;
--ATTRIBUTS
inh table : TDS for
  LACTION , INSTS , INST , INST2 , ELSIF , WITH , WITHS , VAR , EXPR , EXPRTERME , TERME , EXPRFACTEUR , FACTEUR , APP , APP2 , ARGS , ARGSX , EARGS , EXCEPTION;
inh reg : REGLE for
  LACTION;
inh avis : IVisiteurAction for
  LACTION , LOCALES , LOCS , INSTS , INST , ELSIF , WITH , WITHS , EXPR , EXPRTERME , TERME , EXPRFACTEUR , FACTEUR , APP , ARGS , ARGSX , EARGS , EXCEPTION , INST2 , APP2;
inh act : LACT for
  LACTION , LOCALES , LOCS , INSTS , INST , ELSIF , WITH , WITHS , VAR , EXPR , EXPRTERME , TERME , EXPRFACTEUR , FACTEUR , ARGS , ARGSX , APP , EARGS , EXCEPTION , INST2 , APP2;
syn nom : STRING for
  WITH , OPADD , OPMUL;
syn entree : ENTREE for
  VAR;
inh hentree : ENTREE for
  INST2 , APP , APP2 , WITH , WITHS;
syn code : STRING for
  LACTION , LOCALES , LOCS , INSTS , INST , INST2 , ELSIF , WITH , WITHS , EXPR , EXPRTERME , TERME , EXPRFACTEUR , FACTEUR , APP , APP2 , EXCEPTION;
inh hcode : STRING for
  EXPRTERME , EXPRFACTEUR;
syn args : Vector for
  ARGS , EARGS , ARGSX;
inh hargs : Vector for
  ARGS , EARGS , ARGSX;
syn type : IType for
  VTYPE , TYPE , WITH , EXPR , EXPRTERME , TERME , EXPRFACTEUR , FACTEUR , APP , APP2;
inh htype : IType for
  EXPRTERME , EXPRFACTEUR;
syn types : Vector for
  ARGS , EARGS , ARGSX;
inh htypes : Vector for
  ARGS , EARGS , ARGSX;
inh res : Resolveur for
  VTYPE , TYPE , TGEN , XTYPE;
syn pars : Vector for
  TGEN , XTYPE;
syn offset : INTEGER for
  LACTION;
syn length : INTEGER for
  LACTION;

--TERMINAUX
---------------------------------------------------------------

space separateur is "[\r\n\t ]+";
comment commentaires is "\-\-[^\n]*\n";
comment big is "\-\*([^\*]|(\*+[^\*\-]))*\*+\-";
sugar t_point is "\."	aka	$.$;
sugar t_chapeau is "\^"	aka	$^$;
sugar t_virgule is "\,"	aka	$,$;
sugar t_pointvirgule is ";"	aka	$;$;
sugar t_deuxpoints is ":"	aka	$:$;
sugar t_affectation is "(:=)"	aka	$:=$;
sugar t_inf is "\<"	aka	$<$;
sugar t_sup is "\>"	aka	$>$;
sugar t_paro is "\("	aka	$($;
sugar t_parf is "\)"	aka	$)$;
sugar t_is is "is"	aka	$is$;
sugar t_do is "do"	aka	$do$;
sugar t_local is "local"	aka	$local$;
sugar t_end is "end"	aka	$end$;
sugar t_call is "call"	aka	$call$;
sugar t_when is "when"	aka	$when$;
sugar t_error is "error"	aka	$error$;
sugar t_attention is "warning"	aka	$warning$;
sugar t_write is "write"	aka	$write$;
sugar t_new is "new"	aka	$new$;
sugar t_plus is "\+"	aka	$+$;
sugar t_moins is "\-"	aka	$-$;
sugar t_mult is "\*"	aka	$*$;
sugar t_div is "\/"	aka	$/$;
sugar t_d_plus is "\+\."	aka	$+.$;
sugar t_d_moins is "\-\."	aka	$-.$;
sugar t_d_mult is "\*\."	aka	$*.$;
sugar t_d_div is "\/\."	aka	$/.$;
sugar t_et is "(\&|(\&\&))"	aka	$&$, $&&$;
sugar t_ou is "(\||(\|\|))"	aka	$|$, $||$;
sugar t_not is "(\~|\!)"	aka	$~$, $!$;
sugar t_append is "\@"	aka	$@$;
--sugar      t_acf      is    "\}"                  ;

sugar t_if is "if"	aka	$if$;
sugar t_elseif is "elseif"	aka	$elseif$;
sugar t_else is "else"	aka	$else$;
sugar t_match is "match"	aka	$match$;
sugar t_with is "with"	aka	$with$;
sugar t_then is "then"	aka	$then$;
sugar t_begin is "begin"	aka	$begin$;
sugar t_egal is "(=)"	aka	$=$;
sugar t_different is "((\/=)|(\!=))"	aka	$/=$, $!=$;
sugar t_nil is "((nil)|(null))"	aka	$nil$, $null$;
sugar t_true is "true"	aka	$true$;
sugar t_false is "false"	aka	$false$;
--sugar      t_chaine   is    "\""                  ;

sugar t_cro is "\["	aka	$[$;
sugar t_crf is "\]"	aka	$]$;
sugar t_string is "STRING"	aka	$STRING$;
sugar t_integer is "INTEGER"	aka	$INTEGER$;
sugar t_double is "DOUBLE"	aka	$DOUBLE$;
sugar t_char is "CHARACTER"	aka	$CHARACTER$;
sugar t_exception is "exception"	aka	$exception$;
term t_entier is "[0-9]+";
term t_flottant is "[0-9]*\.[0-9]+(e[\+\-]?[0-9]+)?";
-- chars

macro hex is "[0-9a-fA-F]";
macro uni is "\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]";
macro oct is "\\[0-3][0-7][0-7]";
-- le visiteur java les remplace par \n et \t

macro esc is "(\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]|\\[0-3][0-7][0-7]|\\[nrtfb]|\%[NT])";
macro scar is "[^\\\"]";
term t_chaine is "\"((\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]|\\[0-3][0-7][0-7]|\\[nrtfb]|\%[NT])|\\[\\\"]|[^\\\"])*\"";
macro ccar is "[^\\\']";
term t_car is "\'((\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]|\\[0-3][0-7][0-7]|\\[nrtfb]|\%[NT])|\\[\\\']|[^\\\'])\'";
term t_ident is "[a-zA-Z_][a-zA-Z_0-9]*";

--EXTERNES

--REGLES
--LACTION -> t_aco #res LOCALES t_do #inc INSTS t_end t_acf #gen ;

LACTION-> #res LOCALES t_do #inc INSTS EXCEPTION t_end #gen;
global
INTEGER offset;

INTEGER length;

#res{

  offset = LACTION^scanner.getOffset();
  LACTION^avis.resetIndent();
}

#inc{

  LACTION^avis.incIndent();
}

#gen{
  STRING c;

  LACTION^code = LOCALES^code@LACTION^avis.insts()@INSTS^code+EXCEPTION^code;
  LACTION^avis.decIndent();
  length = LACTION^scanner.getOffset()+LACTION^scanner.getLength()-offset;
  LACTION^offset = offset;
  LACTION^length = length;
}

LOCALES-> t_local #inc LOCS #gen;
#inc{

  LOCALES^avis.incIndent();
}

#gen{

  LOCALES^code = LOCALES^avis.locales()@LOCS^code;
  LOCALES^avis.decIndent();
}

LOCALES-> #gen;
#gen{

  LOCALES^code = "";
}

--}

VTYPE-> t_deuxpoints #trans TYPE #gen;
#trans{

  TYPE^res = VTYPE^res;
}

#gen{

  VTYPE^type = TYPE^type;
}

LOCS-> t_ident #trans VTYPE t_pointvirgule #add LOCS #gen;
global
Resolveur r;

#trans{

  r = LOCS^act.getResolveur();
  VTYPE^res = r;
}

#add{
  VAR v;
  TDS_ACTION l;
  ENTREE e;
  BLOC b;

  b = LOCS^act.getBloc();
  l = b.getLocs();
  e = l.chercher(t_ident^txt);
  if (e!=null) {
    error(LACTION_local_yet_declared, t_ident^txt);
	}
  else {
    v =  new VAR(t_ident^txt, VTYPE^type);
    l.ajouter_locale(v);
    r.contDecl(v);
	}
  
}

#gen{
  TDS_ACTION l;
  ENTREE e;
  BLOC b;

  b = LOCS^act.getBloc();
  l = b.getLocs();
  e = l.chercher(t_ident^txt);
  LOCS^code = LOCS^avis.indent()@LOCS^avis.decl(e)@"%N"@LOCS1^code;
}

--LOCS -> t_ident t_deuxpoints #trans TYPE t_pointvirgule #add LOCS #gen ;

LOCS-> #gen;
#gen{

  LOCS^code = "";
}

TYPE-> t_ident #trans TGEN #gen;
#trans{

}

#gen{

  TYPE^type = TYPE^res.getType(t_ident^txt, TGEN^pars);
}

TGEN-> #gen;
#gen{

  TGEN^pars = null;
}

TGEN-> t_inf TYPE XTYPE t_sup #gen;
#gen{

  XTYPE^pars.insertElementAt(TYPE^type, 0);
  TGEN^pars = XTYPE^pars;
}

XTYPE-> t_virgule TYPE XTYPE #add;
#add{

  XTYPE1^pars.insertElementAt(TYPE^type, 0);
  XTYPE^pars = XTYPE1^pars;
}

XTYPE-> #gen;
#gen{

  XTYPE^pars =  new Vector();
}

TYPE-> t_integer #gen;
#gen{

  TYPE^type = TYPE^res.getType("INTEGER");
}

TYPE-> t_double #gen;
#gen{

  TYPE^type = TYPE^res.getType("DOUBLE");
}

TYPE-> t_string #gen;
#gen{

  TYPE^type = TYPE^res.getType("STRING");
}

TYPE-> t_char #gen;
#gen{

  TYPE^type = TYPE^res.getType("CHARACTER");
}

INSTS-> #gen;
#gen{

  INSTS^code = "";
}

INSTS-> INST INSTS #gen;
#gen{

  INSTS^code = INSTS^avis.indent()@INST^code@"%N"@INSTS1^code;
}

EXCEPTION-> #gen;
#gen{

  EXCEPTION^code = "";
}

EXCEPTION-> t_exception t_ident #add INSTS #gen;
global
VAR v;

#add{
  TDS_ACTION l;
  ENTREE e;
  BLOC b;

  b = EXCEPTION^act.getBloc();
  l = b.getLocs();
  e = l.chercher(t_ident^txt);
  if (e!=null) {
    error(LACTION_local_yet_declared, t_ident^txt);
	}
  else {
    v =  new VAR(t_ident^txt, null);
    l.ajouter_locale(v);
    v.setEtat(true);
	}
  
}

#gen{

  EXCEPTION^code = EXCEPTION^avis.exc(t_ident^txt, INSTS^code);
}

INST-> VAR #trans INST2 t_pointvirgule #gen;
#trans{

  INST2^hentree = VAR^entree;
}

#gen{

  INST^code = INST2^code;
}

INST2-> t_affectation EXPR #gen;
#gen{
  Resolveur r;

  if (! INST2^hentree.affectable(INST2^act.getPos())) {
    error(LACTION_var_illegal_access, INST2^hentree.getNom());
	}
  else {
    INST2^hentree.setEtat(true);
    INST2^code = INST2^avis.aff(INST2^hentree, EXPR^code);
    r = INST2^act.getResolveur();
    r.contAff(INST2^hentree, EXPR^type);
	}
  
}

INST2-> APP2 #gen;
#gen{

  INST2^code = APP2^code+";";
}

INST-> t_call #trans VAR #check t_point t_ident t_paro ARGS t_parf t_pointvirgule #gen;
#trans{
  Vector a;
  Vector ts;

  a =  new Vector();
  ARGS^hargs = a;
  ts =  new Vector();
  ARGS^htypes = ts;
}

#check{

  if (! VAR^entree.getEtat()) {
    error(LACTION_var_non_initialized, VAR^entree.getNom());
	}
  elseif (! VAR^entree.utilisable(INST^act.getPos())) {
    error(LACTION_var_illegal_access, VAR^entree.getNom());
	}
  
}

#gen{
  Resolveur r;

  VAR^entree.setEtat(true);
  r = INST^act.getResolveur();
  INST^code = INST^avis.appel(VAR^entree, t_ident^txt, ARGS^args);
}

INST-> t_new #trans VAR t_point t_ident t_paro ARGS t_parf t_pointvirgule #gen;
#trans{
  Vector a;
  Vector ts;

  a =  new Vector();
  ARGS^hargs = a;
  ts =  new Vector();
  ARGS^htypes = ts;
}

#gen{
  Resolveur r;

  if (! VAR^entree.affectable(INST^act.getPos())) {
    error(LACTION_var_illegal_access, VAR^entree.getNom());
	}
  else {
    VAR^entree.setEtat(true);
    INST^code = INST^avis.nouveau(VAR^entree, ARGS^args);
    r = INST^act.getResolveur();
	}
  
}

INST-> t_write EXPR t_pointvirgule #gen;
#gen{

  INST^code = INST^avis.ecrire(EXPR^code);
}

INST-> t_error t_paro t_ident #trans EARGS t_parf t_pointvirgule #gen;
#trans{
  Vector a;
  Vector ts;

  a =  new Vector();
  EARGS^hargs = a;
  ts =  new Vector();
  EARGS^htypes = ts;
}

#gen{
  Resolveur r;

  INST^table.addProperty(t_ident^txt, EARGS^args.size());
  INST^code = INST^avis.fatal(t_ident^txt, EARGS^args);
  r = INST^act.getResolveur();
  r.contErr(EARGS^types);
}

INST-> t_attention t_paro t_ident #trans EARGS t_parf t_pointvirgule #gen;
#trans{
  Vector a;
  Vector ts;

  a =  new Vector();
  EARGS^hargs = a;
  ts =  new Vector();
  EARGS^htypes = ts;
}

#gen{
  Resolveur r;

  INST^table.addProperty(t_ident^txt, EARGS^args.size());
  INST^code = INST^avis.signaler(t_ident^txt, EARGS^args);
  r = INST^act.getResolveur();
  r.contErr(EARGS^types);
}

EARGS-> #gen;
#gen{

  EARGS^args = EARGS^hargs;
  EARGS^types = EARGS^htypes;
}

EARGS-> t_virgule EXPR #add EARGS #gen;
#add{

  EARGS^hargs.add(EXPR^code);
  EARGS^htypes.add(EXPR^type);
  EARGS1^htypes = EARGS^htypes;
}

#gen{

  EARGS^args = EARGS1^args;
  EARGS^types = EARGS1^types;
}

INST-> t_if EXPR t_then #inc INSTS #dec ELSIF t_end #gen;
#inc{

  INST^avis.incIndent();
}

#dec{

  INST^avis.decIndent();
}

#gen{
  STRING a;
  STRING b;

  a = INSTS^code;
  b = ELSIF^code;
  INST^code = INST^avis.ifExpr(EXPR^code, a, b);
}

ELSIF-> t_elseif EXPR t_then #inc INSTS #dec ELSIF #gen;
#inc{

  ELSIF^avis.incIndent();
}

#dec{

  ELSIF^avis.decIndent();
}

#gen{
  STRING a;
  STRING b;

  a = INSTS^code;
  b = ELSIF1^code;
  ELSIF^code = ELSIF^avis.indent()@ELSIF^avis.ifSinonSi(EXPR^code, a, b);
}

ELSIF-> t_else #inc INSTS #gen;
#inc{

  ELSIF^avis.incIndent();
}

#gen{
  STRING a;

  a = INSTS^code;
  ELSIF^avis.decIndent();
  ELSIF^code = ELSIF^avis.indent()@ELSIF^avis.ifSinon(a)@ELSIF^avis.indent()@ELSIF^avis.ifFin();
}

ELSIF-> #gen;
#gen{

  ELSIF^code = ELSIF^avis.indent()@ELSIF^avis.ifFin();
}

VAR-> t_ident #gen;
#gen{
  TDS_ACTION l;
  ENTREE e;
  BLOC b;
  Resolveur r;

  b = VAR^act.getBloc();
  l = b.getLocs();
  e = l.chercher(t_ident^txt);
  if (e==null) {
    error(LACTION_not_a_var, t_ident^txt);
	}
  else {
    VAR^entree = e;
	}
  
}

VAR-> t_ident t_chapeau t_ident #gen;
#gen{
  TDS_ACTION l;
  ENTREE e;
  STRING s;
  BLOC b;
  SYMBOLE symb;
  Resolveur r;

  b = VAR^act.getBloc();
  l = b.getLocs();
  s = t_ident^txt@"^"@t_ident1^txt;
  e = l.chercher(s);
  if (e==null) {
    error(LACTION_not_an_attribute, t_ident1^txt, t_ident^txt);
	}
  else {
    VAR^entree = e;
	}
  
}

INST-> t_match VAR #check WITH WITHS t_end #gen;
#check{

  if (! VAR^entree.getEtat()) {
    error(LACTION_var_non_initialized, VAR^entree.getNom());
	}
  elseif (! VAR^entree.utilisable(INST^act.getPos())) {
    error(LACTION_var_illegal_access, VAR^entree.getNom());
	}
  
  WITH^hentree = VAR^entree;
  WITHS^hentree = VAR^entree;
}

#gen{

  INST^code = INST^avis.matchVarAvec(VAR^entree, WITH^type, WITH^code, WITHS^code)@INST^avis.indent()@INST^avis.matchSi(VAR^entree, WITH^type, WITH^code, WITHS^code);
}

WITH-> t_with #res TYPE #trans t_then INSTS #gen;
#res{
  Resolveur r;

  r = WITH^act.getResolveur();
  TYPE^res = r;
}

#trans{

  WITH^avis.incIndent();
  WITH^avis.transtyper(WITH^hentree, TYPE^type);
}

#gen{

  WITH^type = TYPE^type;
  WITH^nom = TYPE^type.getNom();
  WITH^code = INSTS^code;
  WITH^avis.decIndent();
  WITH^avis.detranstyper(WITH^hentree);
}

WITHS-> WITH WITHS #gen;
#gen{

  WITHS^code = WITHS^avis.indent()@WITHS^avis.matchSinonSi(WITHS^hentree, WITH^type, WITH^code, WITHS1^code);
}

WITHS-> t_else #inc INSTS #gen;
#inc{

  WITHS^avis.incIndent();
}

#gen{
  STRING a;

  a = INSTS^code;
  WITHS^avis.decIndent();
  WITHS^code = WITHS^avis.indent()@WITHS^avis.matchSinon(a)@WITHS^avis.indent()@WITHS^avis.matchFin();
}

WITHS-> #gen;
#gen{

  WITHS^code = WITHS^avis.indent()@WITHS^avis.matchFin();
}

EXPR-> TERME #code EXPRTERME #gen;
#code{

  EXPRTERME^hcode = TERME^code;
  EXPRTERME^htype = TERME^type;
}

#gen{

  EXPR^type = EXPRTERME^type;
  EXPR^code = EXPRTERME^code;
}

EXPRTERME-> OPADD TERME #code EXPRTERME #gen;
#code{
  Resolveur r;

  r = EXPRTERME^act.getResolveur();
  EXPRTERME1^htype = r.contOp(EXPRTERME^htype, OPADD^nom, TERME^type);
  EXPRTERME1^hcode = EXPRTERME^avis.opAdd(EXPRTERME^hcode, OPADD^nom, TERME^code);
}

#gen{

  EXPRTERME^type = EXPRTERME1^type;
  EXPRTERME^code = EXPRTERME1^code;
}

OPADD-> t_egal #gen;
#gen{

  OPADD^nom = "=";
}

OPADD-> t_different #gen;
#gen{

  OPADD^nom = "/=";
}

OPADD-> t_append #gen;
#gen{

  OPADD^nom = "@";
}

OPADD-> t_plus #gen;
#gen{

  OPADD^nom = "+";
}

OPADD-> t_moins #gen;
#gen{

  OPADD^nom = "-";
}

OPADD-> t_d_plus #gen;
#gen{

  OPADD^nom = "+.";
}

OPADD-> t_d_moins #gen;
#gen{

  OPADD^nom = "-.";
}

OPADD-> t_ou #gen;
#gen{

  OPADD^nom = "or";
}

EXPRTERME-> #gen;
#gen{

  EXPRTERME^type = EXPRTERME^htype;
  EXPRTERME^code = EXPRTERME^hcode;
}

TERME-> FACTEUR #code EXPRFACTEUR #gen;
#code{

  EXPRFACTEUR^htype = FACTEUR^type;
  EXPRFACTEUR^hcode = FACTEUR^code;
}

#gen{

  TERME^type = EXPRFACTEUR^type;
  TERME^code = EXPRFACTEUR^code;
}

FACTEUR-> t_nil #gen;
#gen{
  Resolveur r;

  r = FACTEUR^act.getResolveur();
  FACTEUR^type = r.getType("VOID");
  FACTEUR^code = FACTEUR^avis.vide();
}

FACTEUR-> t_true #gen;
#gen{
  Resolveur r;

  r = FACTEUR^act.getResolveur();
  FACTEUR^type = r.getType("BOOLEAN");
  FACTEUR^code = FACTEUR^avis.vrai();
}

FACTEUR-> t_false #gen;
#gen{
  Resolveur r;

  r = FACTEUR^act.getResolveur();
  FACTEUR^type = r.getType("BOOLEAN");
  FACTEUR^code = FACTEUR^avis.faux();
}

FACTEUR-> t_entier #gen;
#gen{
  Resolveur r;

  r = FACTEUR^act.getResolveur();
  FACTEUR^type = r.getType("INTEGER");
  FACTEUR^code = FACTEUR^avis.entier(t_entier^txt);
}

FACTEUR-> t_moins FACTEUR #gen;
#gen{
  Resolveur r;

  r = FACTEUR^act.getResolveur();
  FACTEUR^type = r.getType("INTEGER");
  FACTEUR^code = FACTEUR^avis.moins(FACTEUR1^code);
}

FACTEUR-> t_flottant #gen;
#gen{
  Resolveur r;

  r = FACTEUR^act.getResolveur();
  FACTEUR^type = r.getType("DOUBLE");
  FACTEUR^code = FACTEUR^avis.reel(t_flottant^txt);
}

FACTEUR-> t_car #gen;
#gen{
  Resolveur r;

  r = FACTEUR^act.getResolveur();
  FACTEUR^type = r.getType("CHARACTER");
  FACTEUR^code = FACTEUR^avis.car(t_car^txt);
}

FACTEUR-> t_chaine #gen;
#gen{
  Resolveur r;

  r = FACTEUR^act.getResolveur();
  FACTEUR^type = r.getType("STRING");
  FACTEUR^code = FACTEUR^avis.chaine(t_chaine^txt);
}

FACTEUR-> VAR #check APP #gen;
#check{

  if (! VAR^entree.getEtat()) {
    error(LACTION_var_non_initialized, VAR^entree.getNom());
	}
  elseif (! VAR^entree.utilisable(FACTEUR^act.getPos())) {
    error(LACTION_var_illegal_access, VAR^entree.getNom());
	}
  else {
    APP^hentree = VAR^entree;
	}
  
}

#gen{

  FACTEUR^code = APP^code;
  FACTEUR^type = APP^type;
}

APP-> #gen;
#gen{

  APP^code = APP^avis.var(APP^hentree);
  APP^type = APP^hentree.getType();
}

APP-> APP2 #gen;
#gen{

  APP^code = APP2^code;
  APP^type = APP2^type;
}

APP2-> t_point t_ident #trans t_paro ARGS t_parf #gen;
#trans{
  Vector a;
  Vector ts;

  a =  new Vector();
  ARGS^hargs = a;
  ts =  new Vector();
  ARGS^htypes = ts;
}

#gen{
  Resolveur r;

  r = APP2^act.getResolveur();
  APP2^type = null;
  APP2^code = APP2^avis.fct(APP2^hentree, t_ident^txt, ARGS^args);
}

FACTEUR-> t_not FACTEUR #gen;
#gen{
  Resolveur r;

  r = FACTEUR^act.getResolveur();
  FACTEUR^type = r.contOpNon(FACTEUR1^type);
  FACTEUR^code = FACTEUR^avis.non(FACTEUR1^code);
}

FACTEUR-> t_paro EXPR t_parf #gen;
#gen{

  FACTEUR^type = EXPR^type;
  FACTEUR^code = "("+EXPR^code+")";
}

FACTEUR-> t_new #trans TYPE t_paro ARGS t_parf #gen;
global
Resolveur r;

#trans{
  Vector a;
  Vector ts;

  r = FACTEUR^act.getResolveur();
  TYPE^res = r;
  a =  new Vector();
  ARGS^hargs = a;
  ts =  new Vector();
  ARGS^htypes = ts;
}

#gen{

  FACTEUR^code = FACTEUR^avis.nouveau(TYPE^type, ARGS^args);
  FACTEUR^type = r.contConst(TYPE^type, ARGS^types);
}

EXPRFACTEUR-> OPMUL FACTEUR #code EXPRFACTEUR #gen;
#code{
  Resolveur r;

  r = EXPRFACTEUR^act.getResolveur();
  EXPRFACTEUR1^htype = r.contOp(EXPRFACTEUR^htype, OPMUL^nom, FACTEUR^type);
  EXPRFACTEUR1^hcode = EXPRFACTEUR^avis.opMul(EXPRFACTEUR^hcode, OPMUL^nom, FACTEUR^code);
}

#gen{

  EXPRFACTEUR^type = EXPRFACTEUR1^type;
  EXPRFACTEUR^code = EXPRFACTEUR1^code;
}

OPMUL-> t_et #gen;
#gen{

  OPMUL^nom = "and";
}

OPMUL-> t_mult #gen;
#gen{

  OPMUL^nom = "*";
}

OPMUL-> t_div #gen;
#gen{

  OPMUL^nom = "/";
}

OPMUL-> t_d_mult #gen;
#gen{

  OPMUL^nom = "*.";
}

OPMUL-> t_d_div #gen;
#gen{

  OPMUL^nom = "/.";
}

EXPRFACTEUR-> #gen;
#gen{

  EXPRFACTEUR^type = EXPRFACTEUR^htype;
  EXPRFACTEUR^code = EXPRFACTEUR^hcode;
}

ARGS-> #gen;
#gen{

  ARGS^args = ARGS^hargs;
  ARGS^types = ARGS^htypes;
}

ARGS-> EXPR #expr ARGSX #gen;
#expr{

  ARGS^hargs.add(EXPR^code);
  ARGS^htypes.add(EXPR^type);
  ARGSX^htypes = ARGS^htypes;
}

#gen{

  ARGS^args = ARGSX^args;
  ARGS^types = ARGSX^types;
}

ARGSX-> #gen;
#gen{

  ARGSX^args = ARGSX^hargs;
  ARGSX^types = ARGSX^htypes;
}

ARGSX-> t_virgule EXPR #expr ARGSX #gen;
#expr{

  ARGSX^hargs.add(EXPR^code);
  ARGSX^htypes.add(EXPR^type);
  ARGSX1^htypes = ARGSX^htypes;
}

#gen{

  ARGSX^args = ARGSX1^args;
  ARGSX^types = ARGSX1^types;
}

