----------------------------------
-- les expressions regulieres de gen6 
-- sous-ensemble de JFLEX/JLEX compatible (posix ?) 
------------------------------------
option auto=true;
option k=2;
option version=5.0.0;

inh    vis : IVisiteurEgg for
          EXPREG, REG, TERME, APRTERME,FACTEUR, APRFACTEUR, 
          ELT, ELTS, APRCAR ;
inh   table : TDS for 
          EXPREG, REG, TERME, FACTEUR, APRFACTEUR, APRTERME ;
syn     code    : STRING    for 
          EXPREG, SER, EER, REG, TERME, APRTERME, OP, 
--          OPX,
          FACTEUR, APRFACTEUR, ELT, ELTS, APRCAR ;   

sugar   croco       is          "\["  ; 
sugar   crocf       is          "\]"  ;
sugar   paro        is          "\("  ;
sugar   parf        is          "\)"  ;
sugar   ou          is          "\|"  ;
sugar   moins       is          "\-"  ;
sugar   etoile      is          "\*"  ;
sugar   plus        is          "\+"  ;
sugar   interro     is          "\?"  ;
sugar   neg         is          "\[\^";
sugar   ser         is          "\^"  ;
sugar   eer         is          "\$"  ;
sugar   guillemet   is          "\""  ;
sugar   aco         is          "\{"  ;
sugar   acf         is          "\}"  ;
--sugar   virgule     is          "\,"   ;
sugar   point     is          "\."   ;

-- chars
--macro    hex   is "[0-9a-fA-F]";
macro    uni   is "\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]";
macro    oct   is "\\[0-3][0-7][0-7]";
macro    esc is "({uni}|{oct}|\\.)";

macro    ccar is "[^\'\|\(\)\{\}\[\]\<\>\\\.\*\+\?\^\$\"\~\!]";


--term       entier      is    "[0-9]+";
term       car      is    "({esc}|{ccar})";
term       t_def      is    "\{[a-zA-Z][a-zA-Z0-9_]*\}";

EXPREG -> SER REG EER #gen guillemet ;
#gen {
   do
      EXPREG^code := SER^code @ REG^code @ EER^code;
   end
}

SER -> #gen;
#gen { do SER^code := ""; end }

SER -> ser #gen;
#gen { do SER^code := "^"; end }

EER -> #gen;
#gen { do EER^code := ""; end }

EER -> eer #gen;
#gen { do EER^code := "$"; end }

-- si on veut ne rien preciser ( analyseur exterieur)
REG -> #gen ;
#gen { do REG^code := "" ; end }

REG -> TERME APRTERME #gen ;
#gen { do REG^code := TERME^code @ APRTERME^code ; end } 

TERME ->  FACTEUR OP APRFACTEUR #gen ;
#gen { do TERME^code := FACTEUR^code @ OP^code @ APRFACTEUR^code ; end }

APRTERME -> ou TERME APRTERME #gen ;
#gen { do APRTERME^code := "|" @ TERME^code @ APRTERME1^code ; end }

APRTERME -> #gen ;
#gen { do APRTERME^code := "" ; end }

FACTEUR -> point #gen ;
#gen { do FACTEUR^code := "." ; end }

FACTEUR -> car #gen ;
#gen { do FACTEUR^code := FACTEUR^vis.car(car^txt) ; end }

FACTEUR -> croco ELT ELTS crocf #gen ;
#gen { do FACTEUR^code := "[" @ ELT^code @ ELTS^code @ "]" ; end }

FACTEUR -> neg ELT ELTS crocf #gen ;
#gen { do FACTEUR^code := "[^" @ ELT^code @ ELTS^code @ "]" ; end }

FACTEUR -> paro REG parf #gen ;
#gen { do FACTEUR^code := "(" @ REG^code @ ")" ; end }

FACTEUR -> t_def #gen ;
#gen {
local
  m : STRING ;
  er : STRING ;
  table : TDS;
  s : SYMBOLE;
  t : TERMINAL;
do
  er := "";
  m := t_def^txt.substring(1, t_def^txt.length() -1);
--  write "acces macro " @ m @ " ... " ;
  table := FACTEUR^table;
  s := table.chercher ( m);
  if s = null then
    error(EXPREG_symbol_unknown, m);
    --error ( "symbole inconnu" ) ;
  else
    match s 
    with TERMINAL then
      t := s;
      -- tester si macro
      if s.get_type() = 4 then
        er := s.get_expreg();
      --    write er @"%N" ;
      else
        er := "";
        error(EXPREG_not_a_macro, s.getNom());
        --error ( "macro inconnue" ); 
      end
    else
      er := "";
      error(EXPREG_not_a_macro, s.getNom());
      --error ( "pas une macro" ) ;
    end
  end
  FACTEUR^code := er;
end
}

OP -> etoile #gen ;
#gen { do OP^code := "*" ; end }

OP -> plus #gen ;
#gen { do OP^code := "+" ; end }

OP -> interro #gen ;
#gen { do OP^code := "?" ; end }

OP -> #gen ;
#gen { do OP^code := "" ; end } 

APRFACTEUR -> FACTEUR OP APRFACTEUR #gen ;
#gen { do APRFACTEUR^code := FACTEUR^code @ OP^code @ APRFACTEUR1^code ; end }

APRFACTEUR -> #gen ;
#gen { do APRFACTEUR^code := "" ; end }

ELT -> car APRCAR #gen ;

#gen { do ELT^code := ELT^vis.car(car^txt) @ APRCAR^code ; end } 

ELTS -> ELT ELTS #gen ;
#gen { do ELTS^code := ELT^code @ ELTS1^code ; end }

ELTS -> #gen ;
#gen { do ELTS^code := "" ; end } 

APRCAR -> moins car #gen ;
#gen { do APRCAR^code := "-" @ APRCAR^vis.car(car^txt); end }

APRCAR -> #gen ;
#gen { do APRCAR^code := "" ; end }


end
