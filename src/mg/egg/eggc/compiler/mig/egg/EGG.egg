------------------ ***** -----------------------------
-- Migration de la grammaire de EGG-- vers la nouvelle syntaxe
------------------ ***** -----------------------------
--OPTIONS
option k =1;
option auto =true;
option version =5.4.0;
--ATTRIBUTS
inh source : IEGGCompilationUnit for
  S;
syn type : IType for
  VTYPE , TYPE;
inh res : Resolveur for
  VTYPE , TYPE , TGEN , XTYPE;
syn pars : Vector for
  TGEN , XTYPE;
syn code : STRING for
  IDENT , EXPREG , LACTION;
inh table : TDS for
  OPTIONS , OPTION , ATTRIBUTS , ATTRIBUT , LEXICAUX , LEXICAL , AXIOME , EXTS , IDENTS , PRODUCTIONS , PRODUCTION , PDROITE , EXPREG , GLOBALES , GLOBS , ACTS , LACTION;
-- MESSAGES, 

inh att : ATTRIBUT for
  IDENTS;
syn sorte : INTEGER for
  SATT;
syn ter : TERMINAL for
  LEXICAL;
inh lex : TERMINAL for
  ALIASES , ALIASESX;
inh reg : REGLE for
  PDROITE , ACTS , GLOBALES , GLOBS , LACTION;
inh vis : IVisiteurEgg for
  ATTRIBUTS , ATTRIBUT , LEXICAUX , LEXICAL , EXPREG , AXIOME , EXTS , PRODUCTIONS , PRODUCTION , PDROITE , VTYPE , TYPE , ACTS , TGEN , XTYPE , GLOBALES , GLOBS , IDENT , IDENTS;
--, MESSAGES

inh avis : IVisiteurAction for
  LACTION;
inh act : LACT for
  LACTION;
syn offset : INTEGER for
  LACTION;
syn length : INTEGER for
  LACTION;

--TERMINAUX
space separateurs is "[ \t\n\r]+";
comment commentaires is "\-\-[^\n]*\n";
comment big is "\-\*([^\*]|(\*+[^\*\-]))*\*+\-";
sugar t_inh is "inh"	aka	$inh$;
sugar t_syn is "syn"	aka	$syn$;
sugar t_aka is "aka"	aka	$aka$;
sugar t_deuxpoints is ":"	aka	$:$;
sugar t_aco is "\{"	aka	${$;
sugar t_acf is "\}"	aka	$}$;
sugar t_cro is "\["	aka	$[$;
sugar t_crf is "\]"	aka	$]$;
sugar t_for is "for"	aka	$for$;
sugar t_virgule is "\,"	aka	$,$;
sugar t_pointvirgule is ";"	aka	$;$;
sugar t_inf is "\<"	aka	$<$;
sugar t_sup is "\>"	aka	$>$;
sugar t_fleche is "\-\>"	aka	$->$;
sugar t_option is "option"	aka	$option$;
sugar t_space is "space"	aka	$space$;
sugar t_comm is "comment"	aka	$comment$;
sugar t_sugar is "sugar"	aka	$sugar$;
sugar t_term is "term"	aka	$term$;
sugar t_external is "compil"	aka	$compil$;
sugar t_macro is "macro"	aka	$macro$;
sugar t_is is "is"	aka	$is$;
sugar t_guillemet is "\""	aka	$\"$;
sugar t_end is "end"	aka	$end$;
sugar t_global is "global"	aka	$global$;
sugar t_string is "STRING"	aka	$STRING$;
sugar t_integer is "INTEGER"	aka	$INTEGER$;
sugar t_double is "DOUBLE"	aka	$DOUBLE$;
sugar t_char is "CHARACTER"	aka	$CHARACTER$;
macro mlc is "[A-Za-z0-9_]";
term t_action is "#[A-Za-z0-9_]+";
term t_ident is "[a-zA-Z][A-Za-z0-9_]*";
term t_alias is "\$[^\$]+\$";

--EXTERNES
compil EXPREG;
compil LACTION;
compil OPTION;

--REGLES
S-> #init OPTIONS ATTRIBUTS LEXICAUX EXTS AXIOME PRODUCTIONS t_end #gen;
global
TDS table;

IVisiteurEgg v;

#init{
  ATTRIBUT attribut;
  EGGOptions options;
  INTEGER ce;
  Resolveur r;
  STRING lang;

  table =  new TDS(S^source);
  options = table.getOptions();
  if (! table.verifierOptions()) {
    error(EGG_option_error, options.toString());
	}
  
  OPTIONS^table = table;
  ATTRIBUTS^table = table;
  EXTS^table = table;
  LEXICAUX^table = table;
  AXIOME^table = table;
  PRODUCTIONS^table = table;
  lang = options.getLang();
  if (lang.equals("java")) {
    v =  new VisiteurEggJava(table);
    r =  new LactionResolveur();
	}
  elseif (lang.equals("egg")) {
    v =  new VisiteurEggEgg(table);
    r =  new LactionResolveur();
	}
  elseif (lang.equals("mig")) {
    v =  new VisiteurEggMig(table);
    r =  new LactionResolveur();
	}
  elseif (lang.equals("latex")) {
    v =  new VisiteurEggLatex(table);
    r =  new LactionResolveur();
	}
  elseif (lang.equals("no")) {
    v =  new VisiteurEggNull(table);
    r =  new LactionResolveur();
	}
  else {
    r =  new LactionResolveur();
	}
  
  table.setResolveur(r);
  attribut =  new ATTRIBUT(1, "txt", r.getType("STRING"), S^scanner.getCommentaire());
  attribut.set_builtin();
  table.ajouter_att(attribut);
  attribut =  new ATTRIBUT(0, "scanner", r.getType("LEX_"@table.getNom()), "--scanner");
  attribut.set_builtin();
  table.ajouter_att(attribut);
  attribut =  new ATTRIBUT(0, "eval", r.getType("BOOLEAN"), "-- eval semantic actions");
  attribut.set_builtin();
  table.ajouter_att(attribut);
  LEXICAUX^vis = v;
  ATTRIBUTS^vis = v;
  EXTS^vis = v;
  AXIOME^vis = v;
  PRODUCTIONS^vis = v;
}

#gen{
  INTEGER ce;
  SYMBOLE s;
  Resolveur r;
  BOOLEAN rx;

  table.analyser_syntaxe();
  r = table.getResolveur();
  rx = r.resoudre();
  r.generer();
  v.finaliser();
}

OPTIONS->;
OPTIONS-> t_option OPTION OPTIONS;
ATTRIBUTS-> ATTRIBUT ATTRIBUTS;
ATTRIBUTS->;
SATT-> t_inh #sorte;
#sorte{

  SATT^sorte = 0;
}

SATT-> t_syn #sorte;
#sorte{

  SATT^sorte = 1;
}

--}

VTYPE-> t_deuxpoints #trans TYPE #gen;
#trans{

  TYPE^res = VTYPE^res;
  TYPE^vis = VTYPE^vis;
}

#gen{

  VTYPE^type = TYPE^type;
}

ATTRIBUT-> SATT #trans t_ident VTYPE t_for IDENT #add IDENTS t_pointvirgule;
#trans{

  VTYPE^res = ATTRIBUT^table.getResolveur();
}

#add{
  SYMBOLE symbole;
  ATTRIBUT attribut;
  ATTRIBUT attscan;
  ATTRIBUT atteval;
  NON_TERMINAL nt;

  attribut =  new ATTRIBUT(SATT^sorte, t_ident^txt, VTYPE^type, ATTRIBUT^scanner.getCommentaire());
  if (! ATTRIBUT^table.ajouter_att(attribut)) {
    error(EGG_attribute_yet_declared, t_ident^txt);
	}
  
  nt = null;
  symbole = ATTRIBUT^table.chercher(IDENT^code);
  if (symbole!=null) {
    match (symbole) {
    case NON_TERMINAL {
      nt = symbole;
	}
    default {
      error(EGG_no_terminal_attribute, IDENT^code);
	}
    }

	}
  else {
    nt =  new NON_TERMINAL(IDENT^code);
    ATTRIBUT^table.inserer(nt);
    ATTRIBUT^vis.nt_entete(nt);
    attscan = ATTRIBUT^table.attribut("scanner");
    nt.add_attribut(attscan);
    ATTRIBUT^vis.nt_attribut(nt, attscan);
    atteval = ATTRIBUT^table.attribut("eval");
    nt.add_attribut(atteval);
    ATTRIBUT^vis.nt_attribut(nt, atteval);
	}
  
  nt.add_attribut(attribut);
  ATTRIBUT^vis.nt_attribut(nt, attribut);
  IDENTS^att = attribut;
}

TYPE-> t_ident TGEN #gen;
#gen{

  TYPE^type = TYPE^res.getType(t_ident^txt, TGEN^pars);
}

TGEN-> #gen;
#gen{

  TGEN^pars = null;
}

TGEN-> t_inf TYPE XTYPE t_sup #gen;
#gen{

  XTYPE^pars.insertElementAt(TYPE^type, 0);
  TGEN^pars = XTYPE^pars;
}

XTYPE-> t_virgule TYPE XTYPE #add;
#add{

  XTYPE1^pars.insertElementAt(TYPE^type, 0);
  XTYPE^pars = XTYPE1^pars;
}

XTYPE-> #gen;
#gen{

  XTYPE^pars =  new Vector();
}

TYPE-> t_integer #gen;
#gen{

  TYPE^type = TYPE^res.getType("INTEGER");
}

TYPE-> t_double #gen;
#gen{

  TYPE^type = TYPE^res.getType("DOUBLE");
}

TYPE-> t_string #gen;
#gen{

  TYPE^type = TYPE^res.getType("STRING");
}

TYPE-> t_char #gen;
#gen{

  TYPE^type = TYPE^res.getType("CHARACTER");
}

-- une liste d'identificateurs

IDENTS-> t_virgule IDENT #add IDENTS;
#add{
  SYMBOLE symbole;
  NON_TERMINAL nt;
  ATTRIBUT attribut;
  ATTRIBUT atteval;
  ATTRIBUT a;

  nt = null;
  symbole = IDENTS^table.chercher(IDENT^code);
  if (symbole!=null) {
    match (symbole) {
    case NON_TERMINAL {
      nt = symbole;
	}
    default {
      error(EGG_no_terminal_attribute, IDENT^code);
	}
    }

	}
  else {
    nt =  new NON_TERMINAL(IDENT^code);
    IDENTS^table.inserer(nt);
    IDENTS^vis.nt_entete(nt);
    attribut = IDENTS^table.attribut("scanner");
    nt.add_attribut(attribut);
    IDENTS^vis.nt_attribut(nt, attribut);
    atteval = IDENTS^table.attribut("eval");
    nt.add_attribut(atteval);
    IDENTS^vis.nt_attribut(nt, atteval);
	}
  
  a = nt.attribut(IDENTS^att.getNom());
  if (a==null) {
    nt.add_attribut(IDENTS^att);
    IDENTS^vis.nt_attribut(nt, IDENTS^att);
	}
  else {
    warning(EGG_attribute_yet_declared, IDENTS^att.getNom(), IDENT^code);
	}
  
}

IDENTS-> #fin;
#fin{

  IDENTS^vis.nt_attribut(IDENTS^att);
}

IDENT-> t_ident #gen;
#gen{

  IDENT^code = t_ident^txt;
}

ALIASES->;
ALIASES-> t_aka t_alias #alias ALIASESX;
#alias{

  ALIASES^lex.addName(t_alias^txt);
}

ALIASESX->;
ALIASESX-> t_virgule t_alias #alias ALIASESX;
#alias{

  ALIASESX^lex.addName(t_alias^txt);
}

-- une liste de lexicaux

LEXICAUX-> LEXICAL #add LEXICAUX;
#add{

  if (! LEXICAUX^table.inserer_lexical(LEXICAL^ter)) {
    error(EGG_terminal_yet_declared, LEXICAL^ter.getNom());
	}
  
}

LEXICAUX-> #gen;
#gen{

  LEXICAUX^vis.lexical();
}

-- un separateur

LEXICAL-> t_space t_ident t_is t_guillemet EXPREG #trans ALIASES t_pointvirgule #gen;
global
TERMINAL terminal;

#trans{
  IEGGCompilationUnit cu;
  STRING code;
  INTEGER offset;
  INTEGER length;

  terminal =  new TERMINAL(0, t_ident^txt, EXPREG^code, LEXICAL^scanner.getCommentaire());
  ALIASES^lex = terminal;
  cu = LEXICAL^table.getCompilationUnit();
}

#gen{

  LEXICAL^vis.t_entete(terminal);
  LEXICAL^ter = terminal;
}

-- un sucre syntaxique

LEXICAL-> t_sugar t_ident t_is t_guillemet EXPREG #trans ALIASES t_pointvirgule #gen;
global
TERMINAL terminal;

#trans{

  terminal =  new TERMINAL(1, t_ident^txt, EXPREG^code, LEXICAL^scanner.getCommentaire());
  ALIASES^lex = terminal;
}

#gen{

  LEXICAL^vis.t_entete(terminal);
  LEXICAL^ter = terminal;
}

-- un "vrai" terminal

LEXICAL-> t_term t_ident t_is t_guillemet EXPREG #trans ALIASES t_pointvirgule #gen;
global
TERMINAL terminal;

#trans{

  terminal =  new TERMINAL(2, t_ident^txt, EXPREG^code, LEXICAL^scanner.getCommentaire());
  ALIASES^lex = terminal;
}

#gen{
  ATTRIBUT attribut;
  UN_ATTRIBUT un_attribut;
  ENTREE entree;
  REGLE regle;
  TDS_ACTION table;

  LEXICAL^vis.t_entete(terminal);
  attribut = LEXICAL^table.attribut("txt");
  terminal.add_attribut(attribut);
  attribut = LEXICAL^table.attribut("scanner");
  terminal.add_attribut(attribut);
  LEXICAL^ter = terminal;
}

-- une macro

LEXICAL-> t_macro t_ident t_is t_guillemet EXPREG t_pointvirgule #gen;
#gen{
  TERMINAL terminal;

  terminal =  new TERMINAL(4, t_ident^txt, EXPREG^code, LEXICAL^scanner.getCommentaire());
  LEXICAL^vis.t_entete(terminal);
  LEXICAL^ter = terminal;
}

-- un commentaire

LEXICAL-> t_comm t_ident t_is t_guillemet EXPREG t_pointvirgule #gen;
#gen{
  TERMINAL terminal;

  terminal =  new TERMINAL(5, t_ident^txt, EXPREG^code, LEXICAL^scanner.getCommentaire());
  LEXICAL^vis.t_entete(terminal);
  LEXICAL^ter = terminal;
}

EXTS->;
EXTS-> t_external t_ident t_pointvirgule #gen EXTS;
#gen{
  SYMBOLE symbole;
  NON_TERMINAL nt;
  ATTRIBUT attribut;
  EGG compiler;

  nt = null;
  symbole = EXTS^table.chercher(t_ident^txt);
  if (symbole!=null) {
    match (symbole) {
    case NON_TERMINAL {
      nt = symbole;
	}
    default {
      error(EGG_not_a_non_terminal, t_ident^txt);
	}
    }

	}
  else {
    nt =  new NON_TERMINAL(t_ident^txt);
    EXTS^table.inserer(nt);
    EXTS^vis.ex_entete(nt);
    attribut = EXTS^table.attribut("scanner");
    nt.add_attribut(attribut);
    EXTS^vis.nt_attribut(nt, attribut);
    attribut = EXTS^table.attribut("eval");
    nt.add_attribut(attribut);
    EXTS^vis.nt_attribut(nt, attribut);
	}
  
  nt.setExterne();
}

-- l'axiome de la grammaire a analyser

AXIOME-> t_ident t_fleche #trans PDROITE t_pointvirgule #axiome ACTS;
#trans{
  SYMBOLE symbole;
  NON_TERMINAL nt;
  REGLE regle;
  ATTRIBUT attribut;
  Resolveur r;

  r = AXIOME^table.getResolveur();
  nt = null;
  symbole = null;
  attribut = null;
  symbole = AXIOME^table.chercher(t_ident^txt);
  if (symbole!=null) {
    match (symbole) {
    case NON_TERMINAL {
      nt = symbole;
      AXIOME^table.setAxiome(nt);
	}
    default {
      error(EGG_not_a_non_terminal, t_ident^txt);
	}
    }

	}
  else {
    nt =  new NON_TERMINAL(t_ident^txt);
    AXIOME^table.inserer(nt);
    AXIOME^table.setAxiome(nt);
    AXIOME^vis.nt_entete(nt);
    attribut = AXIOME^table.attribut("scanner");
    nt.add_attribut(attribut);
    AXIOME^vis.nt_attribut(nt, attribut);
    attribut = AXIOME^table.attribut("eval");
    nt.add_attribut(attribut);
    AXIOME^vis.nt_attribut(nt, attribut);
	}
  
  AXIOME^table.ajouter_axiome();
  regle =  new REGLE(AXIOME^table, nt, AXIOME^table.getResolveur(), AXIOME^scanner.getCommentaire());
  AXIOME^table.add_regle(regle);
  nt.add_regle(regle);
  PDROITE^reg = regle;
  ACTS^reg = regle;
  if (AXIOME^table.getAutoAtt()) {
    if (! regle.add_action_inhs()) {
      error(EGG_action_yet_declared, "#auto");
	}
    
	}
  
}

#axiome{

  AXIOME^vis.racine();
  if (! AXIOME^table.getModule()&&AXIOME^table.getMain()) {
    AXIOME^vis.racinec();
	}
  
}

-- une liste de regles de productions

PRODUCTIONS-> PRODUCTION PRODUCTIONS;
PRODUCTIONS->;
-- une regle de production

PRODUCTION-> #init_code t_ident t_fleche #trans PDROITE t_pointvirgule ACTS #fin_code;
global
INTEGER offset;

#init_code{

  offset = PRODUCTION^scanner.getOffset();
}

#fin_code{
  INTEGER length;

  length = PRODUCTION^scanner.getOffset()-offset;
}

#trans{
  ATTRIBUT attribut;
  SYMBOLE symbole;
  NON_TERMINAL nt;
  REGLE regle;

  nt = null;
  symbole = PRODUCTION^table.chercher(t_ident^txt);
  if (symbole==null) {
    nt =  new NON_TERMINAL(t_ident^txt);
    PRODUCTION^table.inserer(nt);
    attribut = PRODUCTION^table.attribut("scanner");
    nt.add_attribut(attribut);
    PRODUCTION^vis.nt_attribut(nt, attribut);
    attribut = PRODUCTION^table.attribut("eval");
    nt.add_attribut(attribut);
    PRODUCTION^vis.nt_attribut(nt, attribut);
	}
  else {
    match (symbole) {
    case NON_TERMINAL {
      nt = symbole;
	}
    default {
      error(EGG_not_a_non_terminal, t_ident^txt);
	}
    }

	}
  
  regle =  new REGLE(PRODUCTION^table, nt, PRODUCTION^table.getResolveur(), PRODUCTION^scanner.getCommentaire());
  PRODUCTION^table.add_regle(regle);
  nt.add_regle(regle);
  PDROITE^reg = regle;
  ACTS^reg = regle;
  PRODUCTION^vis.nt_entete(nt);
  if (PRODUCTION^table.getAutoAtt()) {
    if (! regle.add_action_inhs()) {
      error(EGG_action_yet_declared, "#auto");
	}
    
	}
  
}

PDROITE-> t_ident #add PDROITE;
#add{
  ATTRIBUT attribut;
  SYMBOLE symbole;
  NON_TERMINAL nt;
  TERMINAL t;
  TDS table;

  nt = null;
  symbole = PDROITE^table.chercher(t_ident^txt);
  if (symbole==null) {
    nt =  new NON_TERMINAL(t_ident^txt, PDROITE^scanner.getCommentaire());
    PDROITE^table.inserer(nt);
    attribut = PDROITE^table.attribut("scanner");
    nt.add_attribut(attribut);
    PDROITE^vis.nt_attribut(nt, attribut);
    attribut = PDROITE^table.attribut("eval");
    nt.add_attribut(attribut);
    PDROITE^vis.nt_attribut(nt, attribut);
    symbole = nt;
	}
  else {
    match (symbole) {
    case TERMINAL {
      t = symbole;
      if (t.get_type()==0) {
        error(EGG_space_illegal_here, t_ident^txt);
	}
      
	}
    case NON_TERMINAL {
      nt = symbole;
      if (PDROITE^table.est_axiome(nt)) {
        if (! PDROITE^table.getModule()) {
          error(EGG_axiom_illegal_here, t_ident^txt);
	}
        
	}
      
	}
    default {
	}
    }

	}
  
  PDROITE^reg.add_droite(symbole);
}

PDROITE-> t_action #add PDROITE;
#add{

  if (! PDROITE^reg.add_action(t_action^txt)) {
    error(EGG_action_yet_declared, t_action^txt);
	}
  
}

PDROITE-> #init;
#init{

  PDROITE^reg.init();
  PDROITE^vis.regle(PDROITE^reg);
}

-- une liste de variables globales a la regle

GLOBALES-> t_global GLOBS;
GLOBALES->;
GLOBS-> #trans t_ident VTYPE t_pointvirgule #add GLOBS;
#trans{
  TDS_ACTION t;

  t = GLOBS^reg.getTable();
  VTYPE^res = t.getResolveur();
}

#add{
  GLOB g;
  ENTREE e;
  TDS_ACTION t;
  SymbREGLE sr;
  NON_TERMINAL nt;
  SYMBOLE s;
  Resolveur r;

  t = GLOBS^reg.getTable();
  e = t.chercher(t_ident^txt);
  if (e!=null) {
    error(EGG_global_var_yet_declared, t_ident^txt);
	}
  else {
    g =  new GLOB(GLOBS^reg, t_ident^txt, VTYPE^type);
    t.ajouter_globale(g);
    GLOBS^reg.ajouter_globale(g);
    r = t.getResolveur();
    r.contDecl(g);
    GLOBS^vis.globale(GLOBS^reg, g);
	}
  
}

GLOBS->;
-- une liste d'actions

ACTS-> GLOBALES t_action t_aco #trans LACTION t_acf #add ACTS;
global
ActREGLE a;

#trans{
  STRING c;
  LACT lact;

  a = ACTS^reg.action(t_action^txt);
  if (a!=null) {
    c = a.getCode();
    if (c!=null) {
      error(EGG_action_yet_declared, t_action^txt);
	}
    else {
      lact =  new LACT(ACTS^reg.getTable(), a.getPos());
      LACTION^act = lact;
      LACTION^table = ACTS^table;
      LACTION^avis = ACTS^vis.getVisAction();
	}
    
	}
  else {
    error(EGG_action_useless, t_action^txt, ACTS^reg.toStringSyntaxAction());
	}
  
}

#add{

  if (a!=null) {
    a.setCodeSrc(ACTS^table, LACTION^offset, LACTION^length);
    a.setCode(LACTION^code);
    ACTS^vis.nt_action(a);
	}
  else {
	}
  
}

ACTS-> #regle;
#regle{
  TDS_ACTION t;
  STRING atts;
  LACT lact;
  ActREGLE a;
  LACTION l;
  LEX_CONTEXTE lc;
  LEX_LACTION s;
  STRING acts;

  if (ACTS^table.getAutoAtt()==true) {
    a = ACTS^reg.action("#auto_inh");
    if (a!=null) {
      lact =  new LACT(ACTS^reg.getTable(), a.getPos());
      ACTS^reg.autos(lact);
      if (a.getCodeSrc()!=null) {
        lc =  new LEX_CONTEXTE(a.getCodeSrc());
        l =  new LACTION(ACTS^scanner.getReporter(), lc);
        l.set_act(lact);
        l.set_table(ACTS^table);
        l.set_avis(ACTS^vis.getVisAction());
        s = l.get_scanner();
        s.setReader(s);
        l.set_eval(true);
        l.compile();
        a.setCode(l.get_code());
        ACTS^vis.nt_action(a);
	}
      
	}
    
	}
  
  ACTS^vis.nt_regle(ACTS^reg);
  if (ACTS^table.syntaxOnly()!=true) {
    t = ACTS^reg.getTable();
    atts = t.verifier_initialisations();
    if (atts!=null) {
      error(EGG_attributes_non_initialized, atts, ACTS^reg.toStringSyntaxAction());
	}
    
    acts = ACTS^reg.verifierActions();
    if (acts!=null) {
      error(EGG_undefined_actions, acts, ACTS^reg.toStringSyntaxAction());
	}
    
	}
  
}

